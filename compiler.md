# Content

---
翻译步骤:
- 扫描程序(lexer / scanner): 确定词法单元(token)
- 语法分析程序(parser): 生成AST(abstract syntax tree)
- 语义分析程序(semantic analyzer)
- 源代码优化程序
- 代码生成器
- 目标代码优化程序

## Chapter 2 词法分析
token类型:
- 保留字: IF(if), THEN(then)...
- 特殊符号: MINUS(-), PLUS(+)...
- 多字符串记号: NUM(数字), ID(标识符)...

有穷状态机器:
- DFA(确定性有穷自动机):
    - 构成: 字母表, 状态集合, 转换函数, 初始状态, 接受状态
- NFA(非确定有穷自动机):
    - 增加空跳转函数, 使得转换方式不唯一(如多次使用空跳转函数)
 
状态机的代码实现方式:
- 使用变量记录状态
- 通过switch-case来选择状态, 进行操作, 跳转状态

NFA -> DFA:
- 初始状态的空跳转函数闭包: 初始状态通过空跳转函数可以到达的所有状态的集合
- 构造子集: 通过初始状态闭包和非空跳转字符, 计算跳转后的闭包, 重复此过程直到没有新的状态或转换
- 最小化: 
    - 创建两个集合: 所有接受状态 和 所有非接受状态
    - 如果所有接受状态都有到接受状态的转换函数a, 则定义一个新的接受状态到自身的a函数
    - 如果所有接受状态都有到非接受状态的装换函数a, 则定义一个新的接受状态到新的非接受状态的函数a
    - 如果接受状态s和t在a上有装换, 且位于不同的集合, 则不能定义任何a转换

## Chapter 3 上下文无关文法及分析
分析树 -> 抽象语法树

## Chapter 4 自顶向下的分析
自顶向下(生成-匹配分析):
- 递归下降
- LL(1): 使用显式栈而不是递归调用
  - (分析栈, 输入, 动作)构成表
  - 将文法从右向左压栈, 若栈顶和输入可以匹配, 则弹出, 继续分析
  - First集合, Follow集合

## Chapter 5 自底向上的分析
自底向上(移进-规约分析):
- (分析栈, 输入, 动作)
- 不将文法压栈
- 将输入移进分析栈, 用动作进行规约

LR(0):
- 通过句点描述当前位置
- 将文法中加入句点, 形成多个项目, 构造NFA
- NFA转换DFA(每个DFA集合中包含多个项目)
- 根据输入, 从开始状态起, 进行状态跳转和规约

SLR(1):
- 构造DFA
- 使用Follow集合来决定是否规约

LR(1), LALR()