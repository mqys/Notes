三大部分:
- 程序的结构和执行
- 系统与程序
- 程序间的交互与通信

预处理器 -> 编译器 -> 汇编器 -> 链接器

\*.c -> \*.i -> \*.s (汇编语言文件) -> \*.o (可重定位目标文件) -> 可执行目标文件

-----
# Part I 程序的结构和执行
## Chapter 5 优化程序性能
消除循环的低效: 例如循环中的边界由函数计算得出, 则可以将该函数的计算值保存, 避免每次的重新计算.

优化的基本策略:
1. 高级设计: 使用适当的算法和数据结构
2. 基本编码原则:
    - 消除连续的函数调用
    - 消除不必要的存储器引用
3. 低级优化
    - 展开循环, 降低开销
    - 使用多个累计变量和重新结合技术, 提高指令级并行
    - 用功能的风格重新写条件操作, 使得编译采用条件数据传送     

-----
# Part II 系统与程序
## Chapter 7 链接
链接器的任务:
- 符号解析
- 重定位

目标文件:
- 可重定位目标文件: 包含二进制和数据, 可在**编译时**与其他可重定位木匾文件合并
- 可执行目标文件
- 共享目标文件: 一种特殊的可重定位目标文件, 可以在**加载**或者**运行时**被动态加载到存储器并链接

ELF: executable and linkable format
- 机器码, 全局数据, 符号表, 重定位信息......

三种符号:
- 全局符号: 在模块中定义且能被其他模块引用, 对应非static的函数及非static的全局变量
    - 强符号: 函数和已经初始化的全局变量
    - 弱符号: 未初始化的全局变量
- 外部符号: 由其他模块定义并被本模块引用的全局符号
- 本地符号: 只在本模块使用, 对应static函数和static全局变量
- 注: 定义的本地过程的static变量不在栈中管理
  
| 库 | 后缀 | 文件格式 | 加载 |
|--- | --- | --- | ---|
| 静态库 | \*.a | archive(存档) 一组可重定位目标文件的集合, 由头部来描述成员目标文件的大小和位置 |链接期 |
| 动态库(共享) | \*.so \*.dll | | 链接期不将库包含在目标文件中, 加载时动态加载器再做动态链接 |   

使用`ar`命令将多个\*.o文件封装成\*.a的静态库
  
## Chapter 8 异常控制流
异常: 控制流中的突变, 用来响应处理器状态中的某些变化(事件)
- 中断
- 陷阱
- 故障
- 终止

进程: 一个执行中的程序的实例. 
- 程序: 系统中的每个程序都是运行在某个进程的上下文中的.
- 用户模式 / 内核模式
- 进程控制`fork`, 回收子进程`waitpid`, 加载程序`execve`... 

信号
- 键盘信号: ctrl-c -> SIGINT, ctrl-z -> SIGTSTP, ctrl-d -> EOF
- 函数: `kill`, `alarm`, `signal`

非本地跳转
- `setjmp`, `longjmp`

## Chapter 9 虚拟存储器
写时拷贝(copy-on-write): 在没有进程试图写私有区域的时候, 共享物理存储器中对象的一个单独拷贝. 只要有进程试图写私有区域的某个页面, 那么这个写操作就会触发一个保护故障. 例:`fork`

垃圾收集: 可达图
  
-----
# Part III 程序间的交互与通信
## Chapter 10 系统级I/O
`open`, `read`, `write`

读取文件元数据(文件信息): `stat`, `fstat`

与打开的文件相关的内核中的数据结构:
- 描述符表: 每个进程有独立的描述符号表
- 文件表: 所有进程共享, 包含文件位置 / 引用计数 / v-node表指针
- v-node表: 所有成员共享, 包含`stat`结构中的大多数信息
- 注: 子进程有父进程描述符表的副本

I/O重定向:
`dup2`

Unix I/O 比标准I/O更适合网络应用程序

## Chapter 11 网络编程
网络协议提供的基本功能:
- 命名机制: 分配地址
- 传送机制

UDP: Unreliable Datagram Protocol

大端法与小端法:
- 大端法: 从内存低地址开始存数据的最高位
- 小段法: 从内存低地址开始存数据的最低位
- IP地址结构中使用大端法
- 使用`htonl`/`htons`, `ntohl`/`ntohs`实现网络和主机字节序之间的转换

IP地址和点分十进制转换:
- `inet_aton`, `inet_ntoa`
- 'n' -> 'network(int)', 'a' -> 'application(char*)'

DNS:
- 存储结构:`struct hostent`
- 获取: `gethostbyname`, `gethostbyaddr`

socket:
- 结构: `struct sockaddr`, `struct sockaddr_in`
- 函数: `socket`, `connect`, `bind`, `listen`(将主动套接字转成监听套接字), `accept`(返回已连接描述符)
- 服务端: 监听描述符(`socket`)与已连接描述符(`accept`), 支持并发
 
web服务器:
- 静态内容
- 可执行文件(动态内容)

URL(universal resource locator):
- `?`: 分割文件名和参数
- `&`: 参数隔开符号

## Chapter 12 并发编程
基于进程的并发
- 回收子进程
- 父子进程关闭各自的描述符
- 开销高

基于I/O多路复用的并发
- `select`阻塞, 直到集合中至少有一个可用的描述符
- `select`会修改传入的描述符集合, 需要备份
- 事件驱动: 状态机

基于线程的并发
- 线程是运行在进程上下文中的逻辑流, 包括线程ID/栈/程序计数器..., 共享该进程的整个虚拟地址
- `pthread_create`: 创建线程, 参数由函数参数传入
- `pthread_self`
- `pthread_exit`: 主线程调用则等待其他线程
- `pthread_join`: 回收线程, 只能等待一个指定的线程, 所以需要记录线程号
- `pthread_detach`: 分离线程, (可结合线程能够被其他线程回收和杀死, 分离线程不能, 分离线程由系统释放存储器资源)
- `pthread_once`: 初始化

信号量
- p(s): 非零减一
- v(s): 加一
- `sem_init`, `sem_wait`(p), `sem_post`(v)
- 初始为1的信号量, 用作互斥锁

预线程化并发服务器
- 主线程不断接受请求, 放在缓冲区中
- 实现创建一组工作者线程
- 工作者线程不断从缓冲区取出描述符, 并处理

线程不安全函数
- 不保护共享变量
- 保持跨多个调用的状态的函数
- 返回指向静态变量的指针的函数
- 调用线程不安全函数的函数

可重入函数
- 当他们被多个线程调用时, 不会引用任何共享数据
- 可重入函数是线程安全函数的一个真子集  