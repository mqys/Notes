# Content
- 自动内存管理
- 虚拟机执行子系统
- 程序编译与代码优化
- 高效并发

---
# PART I - 自动内存管理
## Chapter 2 Java内存区域
运行时数据区:
- 程序计数器
- Java虚拟机栈
- 本地方法栈
- Java堆 (新生代和老年代)
- 方法区 (永生代): 类信息, 常量, 静态变量, 即时编译器编译后的代码
- 其他:
    - 运行时常量: 方法区的一部分
    - 直接内存: 不是运行时数据区的一部分, 使用native函数库直接分配堆外内存

对象存储:
- 对象头
- 实例数据
- 对齐填充

## Chapter 3 垃圾收集器
对象生存状态:
- 引用计数 (Reference Counting)
- 可达性分析 (Reachability Analysis)

引用:    
- 强引用 (Strong)
- 软引用 (Soft)
- 弱引用 (Weak)
- 虚引用 (Phantom)

垃圾收集算法:
- 标记-清除算法
- 复制算法 (常用于新生代): 分成两块一次使用一块, 使用完后将存活的复制到另一块上, 回收已使用的整个半区
- 标记-整理算法 (常用于老年代)
- 分代收集算法

垃圾收集器:
- Serial(新生代): 单线程, 需暂停其他所有工作进程
- ParNew(新生代): Serial的多线程版本
- Parallel Scavenge(新生代): 目标是吞吐量
- Serial(老年代): 单线程, 需暂停其他用户进程
- Parallel Old(老年代): 多线程
- CMS(Concurrent Mark Sweep)(老年代): 目标为最短停顿时间, 初始标记-并发标记-重新标记-并发清除
- G1(Region): 初始标记-并发标记-最终标记-筛选回收

并行与并发:
- 并行(Parallel): 多条线程并行, 但其他线程阻塞
- 并发(Concurrent): 用户线程与工作线程同时进行, 不一定是并行的

GC:
- 新生代 (Minor GC)
- 老年代 (Major GC / Full GC)

年龄判定:
- 大对象直接进入老年代
- 对象年龄计数器: 每熬过一个Minor GC年龄增加一岁, 达到一定程度晋升老年代
- 动态年龄判定: 如果Survivor空间中的相同年龄所有对象大小的总和大于Survivor空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代

# PART II - 虚拟机执行子系统
## Chapter 6 类文件结构
JVM只与Class文件(ByteCode)这种特定的二进制文件格式关联. 
- 其他语言可以通过编译成class字节码在虚拟机上运行

Class文件格式:
- 无符号数
- 表

Class文件内容:
- 魔数(magic): 0xCAFEBABE, 版本号
- 常量池(java编译没有链接, 在虚拟机加载class文件的时候进行动态链接)
- 访问标志
- 类索引, 父类索引和接口索引
- 字段表集合(field_info)
- 方法表集合(method_info)
- 属性表集合(attribute_info)

字节码指令: 略

## Chapter 7 虚拟机类加载机制 

# PART III - 程序编译与代码优化

# PART IV - 高效并发